# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/api/v2/endpoint/endpoint.proto, envoy/api/v2/endpoint/endpoint_components.proto, envoy/api/v2/endpoint/load_report.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase


@dataclass(eq=False, repr=False)
class Endpoint(betterproto.Message):
    """Upstream host identifier."""

    # The upstream host address. .. attention::   The form of host address
    # depends on the given cluster type. For STATIC or EDS,   it is expected to
    # be a direct IP address (or something resolvable by the   specified
    # :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`   in the
    # Address). For LOGICAL or STRICT DNS, it is expected to be hostname,   and
    # will be resolved via DNS.
    address: "_core__.Address" = betterproto.message_field(1)
    # The optional health check configuration is used as configuration for the
    # health checker to contact the health checked host. .. attention::   This
    # takes into effect only for upstream clusters with   :ref:`active health
    # checking <arch_overview_health_checking>` enabled.
    health_check_config: "EndpointHealthCheckConfig" = betterproto.message_field(2)
    # The hostname associated with this endpoint. This hostname is not used for
    # routing or address resolution. If provided, it will be associated with the
    # endpoint, and can be used for features that require a hostname, like
    # :ref:`auto_host_rewrite
    # <envoy_api_field_route.RouteAction.auto_host_rewrite>`.
    hostname: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EndpointHealthCheckConfig(betterproto.Message):
    """The optional health check configuration."""

    # Optional alternative health check port value. By default the health check
    # address port of an upstream host is the same as the host's serving address
    # port. This provides an alternative health check port. Setting this with a
    # non-zero value allows an upstream host to have different health check
    # address port.
    port_value: int = betterproto.uint32_field(1)
    # By default, the host header for L7 health checks is controlled by cluster
    # level configuration (see: :ref:`host
    # <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` and
    # :ref:`authority
    # <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>`). Setting
    # this to a non-empty value allows overriding the cluster level configuration
    # for a specific endpoint.
    hostname: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class LbEndpoint(betterproto.Message):
    """An Endpoint that Envoy can route traffic to. [#next-free-field: 6]"""

    endpoint: "Endpoint" = betterproto.message_field(1, group="host_identifier")
    # [#not-implemented-hide:]
    endpoint_name: str = betterproto.string_field(5, group="host_identifier")
    # Optional health status when known and supplied by EDS server.
    health_status: "_core__.HealthStatus" = betterproto.enum_field(2)
    # The endpoint metadata specifies values that may be used by the load
    # balancer to select endpoints in a cluster for a given request. The filter
    # name should be specified as *envoy.lb*. An example boolean key-value pair
    # is *canary*, providing the optional canary status of the upstream host.
    # This may be matched against in a route's :ref:`RouteAction
    # <envoy_api_msg_route.RouteAction>` metadata_match field to subset the
    # endpoints considered in cluster load balancing.
    metadata: "_core__.Metadata" = betterproto.message_field(3)
    # The optional load balancing weight of the upstream host; at least 1. Envoy
    # uses the load balancing weight in some of the built in load balancers. The
    # load balancing weight for an endpoint is divided by the sum of the weights
    # of all endpoints in the endpoint's locality to produce a percentage of
    # traffic for the endpoint. This percentage is then further weighted by the
    # endpoint's locality's load balancing weight from LocalityLbEndpoints. If
    # unspecified, each host is presumed to have equal weight in a locality. The
    # sum of the weights of all endpoints in the endpoint's locality must not
    # exceed uint32_t maximal value (4294967295).
    load_balancing_weight: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )


@dataclass(eq=False, repr=False)
class LocalityLbEndpoints(betterproto.Message):
    """
    A group of endpoints belonging to a Locality. One can have multiple
    LocalityLbEndpoints for a locality, but this is generally only done if the
    different groups need to have different load balancing weights or different
    priorities. [#next-free-field: 7]
    """

    # Identifies location of where the upstream hosts run.
    locality: "_core__.Locality" = betterproto.message_field(1)
    # The group of endpoints belonging to the locality specified.
    lb_endpoints: List["LbEndpoint"] = betterproto.message_field(2)
    # Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
    # balancing weight for a locality is divided by the sum of the weights of all
    # localities  at the same priority level to produce the effective percentage
    # of traffic for the locality. The sum of the weights of all localities at
    # the same priority level must not exceed uint32_t maximal value
    # (4294967295). Locality weights are only considered when :ref:`locality
    # weighted load balancing
    # <arch_overview_load_balancing_locality_weighted_lb>` is configured. These
    # weights are ignored otherwise. If no weights are specified when locality
    # weighted load balancing is enabled, the locality is assigned no load.
    load_balancing_weight: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    # Optional: the priority for this LocalityLbEndpoints. If unspecified this
    # will default to the highest priority (0). Under usual circumstances, Envoy
    # will only select endpoints for the highest priority (0). In the event all
    # endpoints for a particular priority are unavailable/unhealthy, Envoy will
    # fail over to selecting endpoints for the next highest priority group.
    # Priorities should range from 0 (highest) to N (lowest) without skipping.
    priority: int = betterproto.uint32_field(5)
    # Optional: Per locality proximity value which indicates how close this
    # locality is from the source locality. This value only provides ordering
    # information (lower the value, closer it is to the source locality). This
    # will be consumed by load balancing schemes that need proximity order to
    # determine where to route the requests. [#not-implemented-hide:]
    proximity: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_UINT32
    )


@dataclass(eq=False, repr=False)
class UpstreamLocalityStats(betterproto.Message):
    """
    These are stats Envoy reports to GLB every so often. Report frequency is
    defined by :ref:`LoadStatsResponse.load_reporting_interval<envoy_api_field_
    service.load_stats.v2.LoadStatsResponse.load_reporting_interval>`. Stats
    per upstream region/zone and optionally per subzone. [#not-implemented-
    hide:] Not configuration. TBD how to doc proto APIs. [#next-free-field: 9]
    """

    # Name of zone, region and optionally endpoint group these metrics were
    # collected from. Zone and region names could be empty if unknown.
    locality: "_core__.Locality" = betterproto.message_field(1)
    # The total number of requests successfully completed by the endpoints in the
    # locality.
    total_successful_requests: int = betterproto.uint64_field(2)
    # The total number of unfinished requests
    total_requests_in_progress: int = betterproto.uint64_field(3)
    # The total number of requests that failed due to errors at the endpoint,
    # aggregated over all endpoints in the locality.
    total_error_requests: int = betterproto.uint64_field(4)
    # The total number of requests that were issued by this Envoy since the last
    # report. This information is aggregated over all the upstream endpoints in
    # the locality.
    total_issued_requests: int = betterproto.uint64_field(8)
    # Stats for multi-dimensional load balancing.
    load_metric_stats: List["EndpointLoadMetricStats"] = betterproto.message_field(5)
    # Endpoint granularity stats information for this locality. This information
    # is populated if the Server requests it by setting :ref:`LoadStatsResponse.r
    # eport_endpoint_granularity<envoy_api_field_service.load_stats.v2.LoadStatsR
    # esponse.report_endpoint_granularity>`.
    upstream_endpoint_stats: List["UpstreamEndpointStats"] = betterproto.message_field(
        7
    )
    # [#not-implemented-hide:] The priority of the endpoint group these metrics
    # were collected from.
    priority: int = betterproto.uint32_field(6)


@dataclass(eq=False, repr=False)
class UpstreamEndpointStats(betterproto.Message):
    """
    [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
    [#next-free-field: 8]
    """

    # Upstream host address.
    address: "_core__.Address" = betterproto.message_field(1)
    # Opaque and implementation dependent metadata of the endpoint. Envoy will
    # pass this directly to the management server.
    metadata: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(6)
    # The total number of requests successfully completed by the endpoints in the
    # locality. These include non-5xx responses for HTTP, where errors originate
    # at the client and the endpoint responded successfully. For gRPC, the grpc-
    # status values are those not covered by total_error_requests below.
    total_successful_requests: int = betterproto.uint64_field(2)
    # The total number of unfinished requests for this endpoint.
    total_requests_in_progress: int = betterproto.uint64_field(3)
    # The total number of requests that failed due to errors at the endpoint. For
    # HTTP these are responses with 5xx status codes and for gRPC the grpc-status
    # values:   - DeadlineExceeded   - Unimplemented   - Internal   - Unavailable
    # - Unknown   - DataLoss
    total_error_requests: int = betterproto.uint64_field(4)
    # The total number of requests that were issued to this endpoint since the
    # last report. A single TCP connection, HTTP or gRPC request or stream is
    # counted as one request.
    total_issued_requests: int = betterproto.uint64_field(7)
    # Stats for multi-dimensional load balancing.
    load_metric_stats: List["EndpointLoadMetricStats"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class EndpointLoadMetricStats(betterproto.Message):
    """
    [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
    """

    # Name of the metric; may be empty.
    metric_name: str = betterproto.string_field(1)
    # Number of calls that finished and included this metric.
    num_requests_finished_with_metric: int = betterproto.uint64_field(2)
    # Sum of metric values across all calls that finished with this metric for
    # load_reporting_interval.
    total_metric_value: float = betterproto.double_field(3)


@dataclass(eq=False, repr=False)
class ClusterStats(betterproto.Message):
    """
    Per cluster load stats. Envoy reports these stats a management server in a
    :ref:`LoadStatsRequest<envoy_api_msg_service.load_stats.v2.LoadStatsRequest
    >` [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
    Next ID: 7 [#next-free-field: 7]
    """

    # The name of the cluster.
    cluster_name: str = betterproto.string_field(1)
    # The eds_cluster_config service_name of the cluster. It's possible that two
    # clusters send the same service_name to EDS, in that case, the management
    # server is supposed to do aggregation on the load reports.
    cluster_service_name: str = betterproto.string_field(6)
    # Need at least one.
    upstream_locality_stats: List["UpstreamLocalityStats"] = betterproto.message_field(
        2
    )
    # Cluster-level stats such as total_successful_requests may be computed by
    # summing upstream_locality_stats. In addition, below there are additional
    # cluster-wide stats. The total number of dropped requests. This covers
    # requests deliberately dropped by the drop_overload policy and circuit
    # breaking.
    total_dropped_requests: int = betterproto.uint64_field(3)
    # Information about deliberately dropped requests for each category specified
    # in the DropOverload policy.
    dropped_requests: List["ClusterStatsDroppedRequests"] = betterproto.message_field(5)
    # Period over which the actual load report occurred. This will be guaranteed
    # to include every request reported. Due to system load and delays between
    # the *LoadStatsRequest* sent from Envoy and the *LoadStatsResponse* message
    # sent from the management server, this may be longer than the requested load
    # reporting interval in the *LoadStatsResponse*.
    load_report_interval: timedelta = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class ClusterStatsDroppedRequests(betterproto.Message):
    # Identifier for the policy specifying the drop.
    category: str = betterproto.string_field(1)
    # Total number of deliberately dropped requests for the category.
    dropped_count: int = betterproto.uint64_field(2)


from .. import core as _core__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
