# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/api/v2/endpoint/endpoint_components.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto

from envoy_data_plane.envoy.api.v2 import core


@dataclass
class Endpoint(betterproto.Message):
    """Upstream host identifier."""

    # The upstream host address. .. attention::   The form of host address
    # depends on the given cluster type. For STATIC or EDS,   it is expected to
    # be a direct IP address (or something resolvable by the   specified
    # :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`   in the
    # Address). For LOGICAL or STRICT DNS, it is expected to be hostname,   and
    # will be resolved via DNS.
    address: core.Address = betterproto.message_field(1)
    # The optional health check configuration is used as configuration for the
    # health checker to contact the health checked host. .. attention::   This
    # takes into effect only for upstream clusters with   :ref:`active health
    # checking <arch_overview_health_checking>` enabled.
    health_check_config: "EndpointHealthCheckConfig" = betterproto.message_field(2)


@dataclass
class EndpointHealthCheckConfig(betterproto.Message):
    """The optional health check configuration."""

    # Optional alternative health check port value. By default the health check
    # address port of an upstream host is the same as the host's serving address
    # port. This provides an alternative health check port. Setting this with a
    # non-zero value allows an upstream host to have different health check
    # address port.
    port_value: int = betterproto.uint32_field(1)


@dataclass
class LbEndpoint(betterproto.Message):
    """An Endpoint that Envoy can route traffic to. [#next-free-field: 6]"""

    endpoint: "Endpoint" = betterproto.message_field(1, group="host_identifier")
    # [#not-implemented-hide:]
    endpoint_name: str = betterproto.string_field(5, group="host_identifier")
    # Optional health status when known and supplied by EDS server.
    health_status: core.HealthStatus = betterproto.enum_field(2)
    # The endpoint metadata specifies values that may be used by the load
    # balancer to select endpoints in a cluster for a given request. The filter
    # name should be specified as *envoy.lb*. An example boolean key-value pair
    # is *canary*, providing the optional canary status of the upstream host.
    # This may be matched against in a route's :ref:`RouteAction
    # <envoy_api_msg_route.RouteAction>` metadata_match field to subset the
    # endpoints considered in cluster load balancing.
    metadata: core.Metadata = betterproto.message_field(3)
    # The optional load balancing weight of the upstream host; at least 1. Envoy
    # uses the load balancing weight in some of the built in load balancers. The
    # load balancing weight for an endpoint is divided by the sum of the weights
    # of all endpoints in the endpoint's locality to produce a percentage of
    # traffic for the endpoint. This percentage is then further weighted by the
    # endpoint's locality's load balancing weight from LocalityLbEndpoints. If
    # unspecified, each host is presumed to have equal weight in a locality.
    load_balancing_weight: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )


@dataclass
class LocalityLbEndpoints(betterproto.Message):
    """
    A group of endpoints belonging to a Locality. One can have multiple
    LocalityLbEndpoints for a locality, but this is generally only done if the
    different groups need to have different load balancing weights or different
    priorities. [#next-free-field: 7]
    """

    # Identifies location of where the upstream hosts run.
    locality: core.Locality = betterproto.message_field(1)
    # The group of endpoints belonging to the locality specified.
    lb_endpoints: List["LbEndpoint"] = betterproto.message_field(2)
    # Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
    # balancing weight for a locality is divided by the sum of the weights of all
    # localities  at the same priority level to produce the effective percentage
    # of traffic for the locality. Locality weights are only considered when
    # :ref:`locality weighted load balancing
    # <arch_overview_load_balancing_locality_weighted_lb>` is configured. These
    # weights are ignored otherwise. If no weights are specified when locality
    # weighted load balancing is enabled, the locality is assigned no load.
    load_balancing_weight: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    # Optional: the priority for this LocalityLbEndpoints. If unspecified this
    # will default to the highest priority (0). Under usual circumstances, Envoy
    # will only select endpoints for the highest priority (0). In the event all
    # endpoints for a particular priority are unavailable/unhealthy, Envoy will
    # fail over to selecting endpoints for the next highest priority group.
    # Priorities should range from 0 (highest) to N (lowest) without skipping.
    priority: int = betterproto.uint32_field(5)
    # Optional: Per locality proximity value which indicates how close this
    # locality is from the source locality. This value only provides ordering
    # information (lower the value, closer it is to the source locality). This
    # will be consumed by load balancing schemes that need proximity order to
    # determine where to route the requests. [#not-implemented-hide:]
    proximity: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_UINT32
    )
