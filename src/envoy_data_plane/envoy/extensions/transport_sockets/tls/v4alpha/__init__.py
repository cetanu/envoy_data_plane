# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/transport_sockets/tls/v4alpha/common.proto, envoy/extensions/transport_sockets/tls/v4alpha/secret.proto, envoy/extensions/transport_sockets/tls/v4alpha/tls.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase


class TlsParametersTlsProtocol(betterproto.Enum):
    TLS_AUTO = 0
    TLSv1_0 = 1
    TLSv1_1 = 2
    TLSv1_2 = 3
    TLSv1_3 = 4


class CertificateValidationContextTrustChainVerification(betterproto.Enum):
    VERIFY_TRUST_CHAIN = 0
    ACCEPT_UNTRUSTED = 1


class DownstreamTlsContextOcspStaplePolicy(betterproto.Enum):
    LENIENT_STAPLING = 0
    STRICT_STAPLING = 1
    MUST_STAPLE = 2


@dataclass(eq=False, repr=False)
class TlsParameters(betterproto.Message):
    # Minimum TLS protocol version. By default, it's ``TLSv1_2`` for clients and
    # ``TLSv1_0`` for servers.
    tls_minimum_protocol_version: "TlsParametersTlsProtocol" = betterproto.enum_field(1)
    # Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and
    # ``TLSv1_3`` for servers.
    tls_maximum_protocol_version: "TlsParametersTlsProtocol" = betterproto.enum_field(2)
    # If specified, the TLS listener will only support the specified `cipher list
    # <https://commondatastorage.googleapis.com/chromium-boringssl-
    # docs/ssl.h.html#Cipher-suite-configuration>`_ when negotiating TLS 1.0-1.2
    # (this setting has no effect when negotiating TLS 1.3). If not specified,
    # the default list will be used. In non-FIPS builds, the default cipher list
    # is: .. code-block:: none   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-
    # CHACHA20-POLY1305]   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-
    # CHACHA20-POLY1305]   ECDHE-ECDSA-AES128-SHA   ECDHE-RSA-AES128-SHA
    # AES128-GCM-SHA256   AES128-SHA   ECDHE-ECDSA-AES256-GCM-SHA384   ECDHE-RSA-
    # AES256-GCM-SHA384   ECDHE-ECDSA-AES256-SHA   ECDHE-RSA-AES256-SHA
    # AES256-GCM-SHA384   AES256-SHA In builds using :ref:`BoringSSL FIPS
    # <arch_overview_ssl_fips>`, the default cipher list is: .. code-block:: none
    # ECDHE-ECDSA-AES128-GCM-SHA256   ECDHE-RSA-AES128-GCM-SHA256   ECDHE-ECDSA-
    # AES128-SHA   ECDHE-RSA-AES128-SHA   AES128-GCM-SHA256   AES128-SHA   ECDHE-
    # ECDSA-AES256-GCM-SHA384   ECDHE-RSA-AES256-GCM-SHA384   ECDHE-ECDSA-
    # AES256-SHA   ECDHE-RSA-AES256-SHA   AES256-GCM-SHA384   AES256-SHA
    cipher_suites: List[str] = betterproto.string_field(3)
    # If specified, the TLS connection will only support the specified ECDH
    # curves. If not specified, the default curves will be used. In non-FIPS
    # builds, the default curves are: .. code-block:: none   X25519   P-256 In
    # builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default
    # curve is: .. code-block:: none   P-256
    ecdh_curves: List[str] = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class PrivateKeyProvider(betterproto.Message):
    """
    BoringSSL private key method configuration. The private key methods are
    used for external (potentially asynchronous) signing and decryption
    operations. Some use cases for private key methods would be TPM support and
    TLS acceleration.
    """

    # Private key method provider name. The name must match a supported private
    # key method provider type.
    provider_name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )


@dataclass(eq=False, repr=False)
class TlsCertificate(betterproto.Message):
    """[#next-free-field: 7]"""

    # The TLS certificate chain.
    certificate_chain: "____config_core_v4_alpha__.DataSource" = (
        betterproto.message_field(1)
    )
    # The TLS private key.
    private_key: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(2)
    # BoringSSL private key method provider. This is an alternative to
    # :ref:`private_key <envoy_api_field_extensions.transport_sockets.tls.v4alpha
    # .TlsCertificate.private_key>` field. This can't be marked as ``oneof`` due
    # to API compatibility reasons. Setting both :ref:`private_key <envoy_api_fie
    # ld_extensions.transport_sockets.tls.v4alpha.TlsCertificate.private_key>`
    # and :ref:`private_key_provider <envoy_api_field_extensions.transport_socket
    # s.tls.v4alpha.TlsCertificate.private_key_provider>` fields will result in
    # an error.
    private_key_provider: "PrivateKeyProvider" = betterproto.message_field(6)
    # The password to decrypt the TLS private key. If this field is not set, it
    # is assumed that the TLS private key is not password encrypted.
    password: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(3)
    # The OCSP response to be stapled with this certificate during the handshake.
    # The response must be DER-encoded and may only be  provided via ``filename``
    # or ``inline_bytes``. The response may pertain to only one certificate.
    ocsp_staple: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(4)
    # [#not-implemented-hide:]
    signed_certificate_timestamp: List[
        "____config_core_v4_alpha__.DataSource"
    ] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class TlsSessionTicketKeys(betterproto.Message):
    # Keys for encrypting and decrypting TLS session tickets. The first key in
    # the array contains the key to encrypt all new sessions created by this
    # context. All keys are candidates for decrypting received tickets. This
    # allows for easy rotation of keys by, for example, putting the new key
    # first, and the previous key second. If :ref:`session_ticket_keys <envoy_api
    # _field_extensions.transport_sockets.tls.v4alpha.DownstreamTlsContext.sessio
    # n_ticket_keys>` is not specified, the TLS library will still support
    # resuming sessions via tickets, but it will use an internally-generated and
    # managed key, so sessions cannot be resumed across hot restarts or on
    # different hosts. Each key must contain exactly 80 bytes of
    # cryptographically-secure random data. For example, the output of ``openssl
    # rand 80``. .. attention::   Using this feature has serious security
    # considerations and risks. Improper handling of keys   may result in loss of
    # secrecy in connections, even if ciphers supporting perfect forward
    # secrecy are used. See
    # https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
    # discussion. To minimize the risk, you must:   * Keep the session ticket
    # keys at least as secure as your TLS certificate private keys   * Rotate
    # session ticket keys at least daily, and preferably hourly   * Always
    # generate keys using a cryptographically-secure random data source
    keys: List["____config_core_v4_alpha__.DataSource"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CertificateValidationContext(betterproto.Message):
    """[#next-free-field: 11]"""

    # TLS certificate data containing certificate authority certificates to use
    # in verifying a presented peer certificate (e.g. server certificate for
    # clusters or client certificate for listeners). If not specified and a peer
    # certificate is presented it will not be verified. By default, a client
    # certificate is optional, unless one of the additional options
    # (:ref:`require_client_certificate <envoy_api_field_extensions.transport_soc
    # kets.tls.v4alpha.DownstreamTlsContext.require_client_certificate>`,
    # :ref:`verify_certificate_spki <envoy_api_field_extensions.transport_sockets
    # .tls.v4alpha.CertificateValidationContext.verify_certificate_spki>`,
    # :ref:`verify_certificate_hash <envoy_api_field_extensions.transport_sockets
    # .tls.v4alpha.CertificateValidationContext.verify_certificate_hash>`, or
    # :ref:`match_subject_alt_names <envoy_api_field_extensions.transport_sockets
    # .tls.v4alpha.CertificateValidationContext.match_subject_alt_names>`) is
    # also specified. It can optionally contain certificate revocation lists, in
    # which case Envoy will verify that the presented peer certificate has not
    # been revoked by one of the included CRLs. Note that if a CRL is provided
    # for any certificate authority in a trust chain, a CRL must be provided for
    # all certificate authorities in that chain. Failure to do so will result in
    # verification failure for both revoked and unrevoked certificates from that
    # chain. See :ref:`the TLS overview
    # <arch_overview_ssl_enabling_verification>` for a list of common system CA
    # locations.
    trusted_ca: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(1)
    # An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will
    # verify that the SHA-256 of the DER-encoded Subject Public Key Information
    # (SPKI) of the presented certificate matches one of the specified values. A
    # base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the
    # certificate can be generated with the following command: .. code-block::
    # bash   $ openssl x509 -in path/to/client.crt -noout -pubkey     | openssl
    # pkey -pubin -outform DER     | openssl dgst -sha256 -binary     | openssl
    # enc -base64   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A= This is the
    # format used in HTTP Public Key Pinning. When both:
    # :ref:`verify_certificate_hash <envoy_api_field_extensions.transport_sockets
    # .tls.v4alpha.CertificateValidationContext.verify_certificate_hash>` and
    # :ref:`verify_certificate_spki <envoy_api_field_extensions.transport_sockets
    # .tls.v4alpha.CertificateValidationContext.verify_certificate_spki>` are
    # specified, a hash matching value from either of the lists will result in
    # the certificate being accepted. .. attention::   This option is preferred
    # over :ref:`verify_certificate_hash   <envoy_api_field_extensions.transport_
    # sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_hash>`,
    # because SPKI is tied to a private key, so it doesn't change when the
    # certificate   is renewed using the same private key.
    verify_certificate_spki: List[str] = betterproto.string_field(3)
    # An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will
    # verify that the SHA-256 of the DER-encoded presented certificate matches
    # one of the specified values. A hex-encoded SHA-256 of the certificate can
    # be generated with the following command: .. code-block:: bash   $ openssl
    # x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" "
    # -f2   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a A
    # long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the
    # certificate can be generated with the following command: .. code-block::
    # bash   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 |
    # cut -d"=" -f2   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83
    # :FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A Both of those formats are acceptable.
    # When both: :ref:`verify_certificate_hash <envoy_api_field_extensions.transp
    # ort_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_has
    # h>` and :ref:`verify_certificate_spki <envoy_api_field_extensions.transport
    # _sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_spki>`
    # are specified, a hash matching value from either of the lists will result
    # in the certificate being accepted.
    verify_certificate_hash: List[str] = betterproto.string_field(2)
    # An optional list of Subject Alternative name matchers. Envoy will verify
    # that the Subject Alternative Name of the presented certificate matches one
    # of the specified matches. When a certificate has wildcard DNS SAN entries,
    # to match a specific client, it should be configured with exact match type
    # in the :ref:`string matcher
    # <envoy_api_msg_type.matcher.v4alpha.StringMatcher>`. For example if the
    # certificate has "\*.example.com" as DNS SAN entry, to allow only
    # "api.example.com", it should be configured as shown below. .. code-block::
    # yaml  match_subject_alt_names:    exact: "api.example.com" .. attention::
    # Subject Alternative Names are easily spoofable and verifying only them is
    # insecure,   therefore this option must be used together with
    # :ref:`trusted_ca   <envoy_api_field_extensions.transport_sockets.tls.v4alph
    # a.CertificateValidationContext.trusted_ca>`.
    match_subject_alt_names: List[
        "____type_matcher_v4_alpha__.StringMatcher"
    ] = betterproto.message_field(9)
    # [#not-implemented-hide:] Must present signed certificate time-stamp.
    require_signed_certificate_timestamp: Optional[bool] = betterproto.message_field(
        6, wraps=betterproto.TYPE_BOOL
    )
    # An optional `certificate revocation list
    # <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_ (in PEM
    # format). If specified, Envoy will verify that the presented peer
    # certificate has not been revoked by this CRL. If this DataSource contains
    # multiple CRLs, all of them will be used. Note that if a CRL is provided for
    # any certificate authority in a trust chain, a CRL must be provided for all
    # certificate authorities in that chain. Failure to do so will result in
    # verification failure for both revoked and unrevoked certificates from that
    # chain.
    crl: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(7)
    # If specified, Envoy will not reject expired certificates.
    allow_expired_certificate: bool = betterproto.bool_field(8)
    # Certificate trust chain verification mode.
    trust_chain_verification: "CertificateValidationContextTrustChainVerification" = (
        betterproto.enum_field(10)
    )


@dataclass(eq=False, repr=False)
class GenericSecret(betterproto.Message):
    # Secret of generic type and is available to filters.
    secret: "____config_core_v4_alpha__.DataSource" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SdsSecretConfig(betterproto.Message):
    # Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely
    # referred to. When both name and config are specified, then secret can be
    # fetched and/or reloaded via SDS. When only name is specified, then secret
    # will be loaded from static resources.
    name: str = betterproto.string_field(1, group="name_specifier")
    # Resource locator for SDS. This is mutually exclusive to *name*. [#not-
    # implemented-hide:]
    sds_resource_locator: "_____udpa_core_v1__.ResourceLocator" = (
        betterproto.message_field(3, group="name_specifier")
    )
    sds_config: "____config_core_v4_alpha__.ConfigSource" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Secret(betterproto.Message):
    """[#next-free-field: 6]"""

    # Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely
    # referred to.
    name: str = betterproto.string_field(1)
    tls_certificate: "TlsCertificate" = betterproto.message_field(2, group="type")
    session_ticket_keys: "TlsSessionTicketKeys" = betterproto.message_field(
        3, group="type"
    )
    validation_context: "CertificateValidationContext" = betterproto.message_field(
        4, group="type"
    )
    generic_secret: "GenericSecret" = betterproto.message_field(5, group="type")


@dataclass(eq=False, repr=False)
class UpstreamTlsContext(betterproto.Message):
    # Common TLS context settings. .. attention::   Server certificate
    # verification is not enabled by default. Configure   :ref:`trusted_ca<envoy_
    # api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationCon
    # text.trusted_ca>` to enable   verification.
    common_tls_context: "CommonTlsContext" = betterproto.message_field(1)
    # SNI string to use when creating TLS backend connections.
    sni: str = betterproto.string_field(2)
    # If true, server-initiated TLS renegotiation will be allowed. .. attention::
    # TLS renegotiation is considered insecure and shouldn't be used unless
    # absolutely necessary.
    allow_renegotiation: bool = betterproto.bool_field(3)
    # Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs
    # and Session Tickets for TLSv1.2 and older) to store for the purpose of
    # session resumption. Defaults to 1, setting this to 0 disables session
    # resumption.
    max_session_keys: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )


@dataclass(eq=False, repr=False)
class DownstreamTlsContext(betterproto.Message):
    """[#next-free-field: 9]"""

    # Common TLS context settings.
    common_tls_context: "CommonTlsContext" = betterproto.message_field(1)
    # If specified, Envoy will reject connections without a valid client
    # certificate.
    require_client_certificate: Optional[bool] = betterproto.message_field(
        2, wraps=betterproto.TYPE_BOOL
    )
    # If specified, Envoy will reject connections without a valid and matching
    # SNI. [#not-implemented-hide:]
    require_sni: Optional[bool] = betterproto.message_field(
        3, wraps=betterproto.TYPE_BOOL
    )
    # TLS session ticket key settings.
    session_ticket_keys: "TlsSessionTicketKeys" = betterproto.message_field(
        4, group="session_ticket_keys_type"
    )
    # Config for fetching TLS session ticket keys via SDS API.
    session_ticket_keys_sds_secret_config: "SdsSecretConfig" = (
        betterproto.message_field(5, group="session_ticket_keys_type")
    )
    # Config for controlling stateless TLS session resumption: setting this to
    # true will cause the TLS server to not issue TLS session tickets for the
    # purposes of stateless TLS session resumption. If set to false, the TLS
    # server will issue TLS session tickets and encrypt/decrypt them using the
    # keys specified through either :ref:`session_ticket_keys <envoy_api_field_ex
    # tensions.transport_sockets.tls.v4alpha.DownstreamTlsContext.session_ticket_
    # keys>` or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_exte
    # nsions.transport_sockets.tls.v4alpha.DownstreamTlsContext.session_ticket_ke
    # ys_sds_secret_config>`. If this config is set to false and no keys are
    # explicitly configured, the TLS server will issue TLS session tickets and
    # encrypt/decrypt them using an internally-generated and managed key, with
    # the implication that sessions cannot be resumed across hot restarts or on
    # different hosts.
    disable_stateless_session_resumption: bool = betterproto.bool_field(
        7, group="session_ticket_keys_type"
    )
    # If specified, session_timeout will change maximum lifetime (in seconds) of
    # TLS session Currently this value is used as a hint to `TLS session ticket
    # lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`
    # only seconds could be specified (fractional seconds are going to be
    # ignored).
    session_timeout: timedelta = betterproto.message_field(6)
    # Config for whether to use certificates if they do not have an accompanying
    # OCSP response or if the response expires at runtime. Defaults to
    # LENIENT_STAPLING
    ocsp_staple_policy: "DownstreamTlsContextOcspStaplePolicy" = betterproto.enum_field(
        8
    )


@dataclass(eq=False, repr=False)
class CommonTlsContext(betterproto.Message):
    """
    TLS context shared by both client and server TLS contexts. [#next-free-
    field: 14]
    """

    # TLS protocol versions, cipher suites etc.
    tls_params: "TlsParameters" = betterproto.message_field(1)
    # :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be
    # associated with the same context to allow both RSA and ECDSA certificates.
    # Only a single TLS certificate is supported in client contexts. In server
    # contexts, the first RSA certificate is used for clients that only support
    # RSA and the first ECDSA certificate is used for clients that support ECDSA.
    tls_certificates: List["TlsCertificate"] = betterproto.message_field(2)
    # Configs for fetching TLS certificates via SDS API. Note SDS API allows
    # certificates to be fetched/refreshed over the network asynchronously with
    # respect to the TLS handshake.
    tls_certificate_sds_secret_configs: List[
        "SdsSecretConfig"
    ] = betterproto.message_field(6)
    # Certificate provider for fetching TLS certificates. [#not-implemented-
    # hide:]
    tls_certificate_certificate_provider: "CommonTlsContextCertificateProvider" = (
        betterproto.message_field(9)
    )
    # Certificate provider instance for fetching TLS certificates. [#not-
    # implemented-hide:]
    tls_certificate_certificate_provider_instance: "CommonTlsContextCertificateProviderInstance" = betterproto.message_field(
        11
    )
    # How to validate peer certificates.
    validation_context: "CertificateValidationContext" = betterproto.message_field(
        3, group="validation_context_type"
    )
    # Config for fetching validation context via SDS API. Note SDS API allows
    # certificates to be fetched/refreshed over the network asynchronously with
    # respect to the TLS handshake.
    validation_context_sds_secret_config: "SdsSecretConfig" = betterproto.message_field(
        7, group="validation_context_type"
    )
    # Combined certificate validation context holds a default
    # CertificateValidationContext and SDS config. When SDS server returns
    # dynamic CertificateValidationContext, both dynamic and default
    # CertificateValidationContext are merged into a new
    # CertificateValidationContext for validation. This merge is done by
    # Message::MergeFrom(), so dynamic CertificateValidationContext overwrites
    # singular fields in default CertificateValidationContext, and concatenates
    # repeated fields to default CertificateValidationContext, and logical OR is
    # applied to boolean fields.
    combined_validation_context: "CommonTlsContextCombinedCertificateValidationContext" = betterproto.message_field(
        8, group="validation_context_type"
    )
    # Certificate provider for fetching validation context. [#not-implemented-
    # hide:]
    validation_context_certificate_provider: "CommonTlsContextCertificateProvider" = (
        betterproto.message_field(10, group="validation_context_type")
    )
    # Certificate provider instance for fetching validation context. [#not-
    # implemented-hide:]
    validation_context_certificate_provider_instance: "CommonTlsContextCertificateProviderInstance" = betterproto.message_field(
        12, group="validation_context_type"
    )
    # Supplies the list of ALPN protocols that the listener should expose. In
    # practice this is likely to be set to one of two values (see the
    # :ref:`codec_type <envoy_api_field_extensions.filters.network.http_connectio
    # n_manager.v4alpha.HttpConnectionManager.codec_type>` parameter in the HTTP
    # connection manager for more information): * "h2,http/1.1" If the listener
    # is going to support both HTTP/2 and HTTP/1.1. * "http/1.1" If the listener
    # is only going to support HTTP/1.1. There is no default for this parameter.
    # If empty, Envoy will not expose ALPN.
    alpn_protocols: List[str] = betterproto.string_field(4)
    # Custom TLS handshaker. If empty, defaults to native TLS handshaking
    # behavior.
    custom_handshaker: "____config_core_v4_alpha__.TypedExtensionConfig" = (
        betterproto.message_field(13)
    )


@dataclass(eq=False, repr=False)
class CommonTlsContextCertificateProvider(betterproto.Message):
    """
    Config for Certificate provider to get certificates. This provider should
    allow certificates to be fetched/refreshed over the network asynchronously
    with respect to the TLS handshake.
    """

    # opaque name used to specify certificate instances or types. For example,
    # "ROOTCA" to specify a root-certificate (validation context) or "TLS" to
    # specify a new tls-certificate.
    name: str = betterproto.string_field(1)
    typed_config: "____config_core_v4_alpha__.TypedExtensionConfig" = (
        betterproto.message_field(2, group="config")
    )


@dataclass(eq=False, repr=False)
class CommonTlsContextCertificateProviderInstance(betterproto.Message):
    """
    Similar to CertificateProvider above, but allows the provider instances to
    be configured on the client side instead of being sent from the control
    plane.
    """

    # Provider instance name. This name must be defined in the client's
    # configuration (e.g., a bootstrap file) to correspond to a provider instance
    # (i.e., the same data in the typed_config field that would be sent in the
    # CertificateProvider message if the config was sent by the control plane).
    # If not present, defaults to "default". Instance names should generally be
    # defined not in terms of the underlying provider implementation (e.g.,
    # "file_watcher") but rather in terms of the function of the certificates
    # (e.g., "foo_deployment_identity").
    instance_name: str = betterproto.string_field(1)
    # Opaque name used to specify certificate instances or types. For example,
    # "ROOTCA" to specify a root-certificate (validation context) or
    # "example.com" to specify a certificate for a particular domain. Not all
    # provider instances will actually use this field, so the value defaults to
    # the empty string.
    certificate_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CommonTlsContextCombinedCertificateValidationContext(betterproto.Message):
    # How to validate peer certificates.
    default_validation_context: "CertificateValidationContext" = (
        betterproto.message_field(1)
    )
    # Config for fetching validation context via SDS API. Note SDS API allows
    # certificates to be fetched/refreshed over the network asynchronously with
    # respect to the TLS handshake. Only one of
    # validation_context_sds_secret_config,
    # validation_context_certificate_provider, or
    # validation_context_certificate_provider_instance may be used.
    validation_context_sds_secret_config: "SdsSecretConfig" = betterproto.message_field(
        2, group="dynamic_validation_context"
    )
    # Certificate provider for fetching validation context. Only one of
    # validation_context_sds_secret_config,
    # validation_context_certificate_provider, or
    # validation_context_certificate_provider_instance may be used. [#not-
    # implemented-hide:]
    validation_context_certificate_provider: "CommonTlsContextCertificateProvider" = (
        betterproto.message_field(3, group="dynamic_validation_context")
    )
    # Certificate provider instance for fetching validation context. Only one of
    # validation_context_sds_secret_config,
    # validation_context_certificate_provider, or
    # validation_context_certificate_provider_instance may be used. [#not-
    # implemented-hide:]
    validation_context_certificate_provider_instance: "CommonTlsContextCertificateProviderInstance" = betterproto.message_field(
        4, group="dynamic_validation_context"
    )


from ......udpa.core import v1 as _____udpa_core_v1__
from .....config.core import v4alpha as ____config_core_v4_alpha__
from .....type.matcher import v4alpha as ____type_matcher_v4_alpha__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
