# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase


@dataclass(eq=False, repr=False)
class UdpProxyConfig(betterproto.Message):
    """Configuration for the UDP proxy filter. [#next-free-field: 8]"""

    # The stat prefix used when emitting UDP proxy filter stats.
    stat_prefix: str = betterproto.string_field(1)
    # The upstream cluster to connect to.
    cluster: str = betterproto.string_field(2, group="route_specifier")
    # The idle timeout for sessions. Idle is defined as no datagrams between
    # received or sent by the session. The default if not specified is 1 minute.
    idle_timeout: timedelta = betterproto.message_field(3)
    # Use the remote downstream IP address as the sender IP address when sending
    # packets to upstream hosts. This option requires Envoy to be run with the
    # *CAP_NET_ADMIN* capability on Linux. And the IPv6 stack must be enabled on
    # Linux kernel. This option does not preserve the remote downstream port. If
    # this option is enabled, the IP address of sent datagrams will be changed to
    # the remote downstream IP address. This means that Envoy will not receive
    # packets that are sent by upstream hosts because the upstream hosts will
    # send the packets with the remote downstream IP address as the destination.
    # All packets will be routed to the remote downstream directly if there are
    # route rules on the upstream host side. There are two options to return the
    # packets back to the remote downstream. The first one is to use DSR (Direct
    # Server Return). The other one is to configure routing rules on the upstream
    # hosts to forward all packets back to Envoy and configure iptables rules on
    # the host running Envoy to forward all packets from upstream hosts to the
    # Envoy process so that Envoy can forward the packets to the downstream. If
    # the platform does not support this option, Envoy will raise a configuration
    # error.
    use_original_src_ip: bool = betterproto.bool_field(4)
    # Optional configuration for UDP proxy hash policies. If hash_policies is not
    # set, the hash-based load balancing algorithms will select a host randomly.
    # Currently the number of hash policies is limited to 1.
    hash_policies: List["UdpProxyConfigHashPolicy"] = betterproto.message_field(5)
    # UDP socket configuration for upstream sockets. The default for
    # :ref:`prefer_gro
    # <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for
    # upstream sockets as the assumption is datagrams will be received from a
    # single source.
    upstream_socket_config: "_____config_core_v3__.UdpSocketConfig" = (
        betterproto.message_field(6)
    )
    # Perform per packet load balancing (upstream host selection) on each
    # received data chunk. The default if not specified is false, that means each
    # data chunk is forwarded to upstream host selected on first chunk receival
    # for that "session" (identified by source IP/port and local IP/port).
    use_per_packet_load_balancing: bool = betterproto.bool_field(7)


@dataclass(eq=False, repr=False)
class UdpProxyConfigHashPolicy(betterproto.Message):
    """
    Specifies the UDP hash policy. The packets can be routed by hash policy.
    """

    # The source IP will be used to compute the hash used by hash-based load
    # balancing algorithms.
    source_ip: bool = betterproto.bool_field(1, group="policy_specifier")
    # A given key will be used to compute the hash used by hash-based load
    # balancing algorithms. In certain cases there is a need to direct different
    # UDP streams jointly towards the selected set of endpoints. A possible use-
    # case is VoIP telephony, where media (RTP) and its corresponding control
    # (RTCP) belong to the same logical session, although they travel in separate
    # streams. To ensure that these pair of streams are load-balanced on session
    # level (instead of individual stream level), dynamically created listeners
    # can use the same hash key for each stream in the session.
    key: str = betterproto.string_field(2, group="policy_specifier")


from ......config.core import v3 as _____config_core_v3__
