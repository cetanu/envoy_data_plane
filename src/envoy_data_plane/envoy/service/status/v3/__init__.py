# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/status/v3/csds.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class ConfigStatus(betterproto.Enum):
    """Status of a config from a management server view."""

    # Status info is not available/unknown.
    UNKNOWN = 0
    # Management server has sent the config to client and received ACK.
    SYNCED = 1
    # Config is not sent.
    NOT_SENT = 2
    # Management server has sent the config to client but hasnâ€™t received
    # ACK/NACK.
    STALE = 3
    # Management server has sent the config to client but received NACK. The
    # attached config dump will be the latest config (the rejected one), since it
    # is the persisted version in the management server.
    ERROR = 4


class ClientConfigStatus(betterproto.Enum):
    """Config status from a client-side view."""

    # Config status is not available/unknown.
    CLIENT_UNKNOWN = 0
    # Client requested the config but hasn't received any config from management
    # server yet.
    CLIENT_REQUESTED = 1
    # Client received the config and replied with ACK.
    CLIENT_ACKED = 2
    # Client received the config and replied with NACK. Notably, the attached
    # config dump is not the NACKed version, but the most recent accepted one. If
    # no config is accepted yet, the attached config dump will be empty.
    CLIENT_NACKED = 3


@dataclass(eq=False, repr=False)
class ClientStatusRequest(betterproto.Message):
    """
    Request for client status of clients identified by a list of NodeMatchers.
    """

    # Management server can use these match criteria to identify clients. The
    # match follows OR semantics.
    node_matchers: List["___type_matcher_v3__.NodeMatcher"] = betterproto.message_field(
        1
    )
    # The node making the csds request.
    node: "___config_core_v3__.Node" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PerXdsConfig(betterproto.Message):
    """Detailed config (per xDS) with status. [#next-free-field: 8]"""

    # Config status generated by management servers. Will not be present if the
    # CSDS server is an xDS client.
    status: "ConfigStatus" = betterproto.enum_field(1)
    # Client config status is populated by xDS clients. Will not be present if
    # the CSDS server is an xDS server. No matter what the client config status
    # is, xDS clients should always dump the most recent accepted xDS config.
    client_status: "ClientConfigStatus" = betterproto.enum_field(7)
    listener_config: "___admin_v3__.ListenersConfigDump" = betterproto.message_field(
        2, group="per_xds_config"
    )
    cluster_config: "___admin_v3__.ClustersConfigDump" = betterproto.message_field(
        3, group="per_xds_config"
    )
    route_config: "___admin_v3__.RoutesConfigDump" = betterproto.message_field(
        4, group="per_xds_config"
    )
    scoped_route_config: "___admin_v3__.ScopedRoutesConfigDump" = (
        betterproto.message_field(5, group="per_xds_config")
    )
    endpoint_config: "___admin_v3__.EndpointsConfigDump" = betterproto.message_field(
        6, group="per_xds_config"
    )


@dataclass(eq=False, repr=False)
class ClientConfig(betterproto.Message):
    """All xds configs for a particular client."""

    # Node for a particular client.
    node: "___config_core_v3__.Node" = betterproto.message_field(1)
    xds_config: List["PerXdsConfig"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ClientStatusResponse(betterproto.Message):
    # Client configs for the clients specified in the ClientStatusRequest.
    config: List["ClientConfig"] = betterproto.message_field(1)


class ClientStatusDiscoveryServiceStub(betterproto.ServiceStub):
    async def stream_client_status(
        self,
        request_iterator: Union[
            AsyncIterable["ClientStatusRequest"], Iterable["ClientStatusRequest"]
        ],
    ) -> AsyncIterator["ClientStatusResponse"]:

        async for response in self._stream_stream(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/StreamClientStatus",
            request_iterator,
            ClientStatusRequest,
            ClientStatusResponse,
        ):
            yield response

    async def fetch_client_status(
        self,
        *,
        node_matchers: Optional[List["___type_matcher_v3__.NodeMatcher"]] = None,
        node: "___config_core_v3__.Node" = None,
    ) -> "ClientStatusResponse":
        node_matchers = node_matchers or []

        request = ClientStatusRequest()
        if node_matchers is not None:
            request.node_matchers = node_matchers
        if node is not None:
            request.node = node

        return await self._unary_unary(
            "/envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus",
            request,
            ClientStatusResponse,
        )


class ClientStatusDiscoveryServiceBase(ServiceBase):
    async def stream_client_status(
        self, request_iterator: AsyncIterator["ClientStatusRequest"]
    ) -> AsyncIterator["ClientStatusResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_client_status(
        self,
        node_matchers: Optional[List["___type_matcher_v3__.NodeMatcher"]],
        node: "___config_core_v3__.Node",
    ) -> "ClientStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_client_status(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        await self._call_rpc_handler_server_stream(
            self.stream_client_status,
            stream,
            request_kwargs,
        )

    async def __rpc_fetch_client_status(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "node_matchers": request.node_matchers,
            "node": request.node,
        }

        response = await self.fetch_client_status(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/envoy.service.status.v3.ClientStatusDiscoveryService/StreamClientStatus": grpclib.const.Handler(
                self.__rpc_stream_client_status,
                grpclib.const.Cardinality.STREAM_STREAM,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
            "/envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus": grpclib.const.Handler(
                self.__rpc_fetch_client_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
        }


from ....admin import v3 as ___admin_v3__
from ....config.core import v3 as ___config_core_v3__
from ....type.matcher import v3 as ___type_matcher_v3__
