# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/status/v2/csds.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class ConfigStatus(betterproto.Enum):
    """Status of a config."""

    # Status info is not available/unknown.
    UNKNOWN = 0
    # Management server has sent the config to client and received ACK.
    SYNCED = 1
    # Config is not sent.
    NOT_SENT = 2
    # Management server has sent the config to client but hasnâ€™t received
    # ACK/NACK.
    STALE = 3
    # Management server has sent the config to client but received NACK.
    ERROR = 4


@dataclass(eq=False, repr=False)
class ClientStatusRequest(betterproto.Message):
    """
    Request for client status of clients identified by a list of NodeMatchers.
    """

    # Management server can use these match criteria to identify clients. The
    # match follows OR semantics.
    node_matchers: List["___type_matcher__.NodeMatcher"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PerXdsConfig(betterproto.Message):
    """Detailed config (per xDS) with status. [#next-free-field: 6]"""

    status: "ConfigStatus" = betterproto.enum_field(1)
    listener_config: "___admin_v2_alpha__.ListenersConfigDump" = (
        betterproto.message_field(2, group="per_xds_config")
    )
    cluster_config: "___admin_v2_alpha__.ClustersConfigDump" = (
        betterproto.message_field(3, group="per_xds_config")
    )
    route_config: "___admin_v2_alpha__.RoutesConfigDump" = betterproto.message_field(
        4, group="per_xds_config"
    )
    scoped_route_config: "___admin_v2_alpha__.ScopedRoutesConfigDump" = (
        betterproto.message_field(5, group="per_xds_config")
    )


@dataclass(eq=False, repr=False)
class ClientConfig(betterproto.Message):
    """All xds configs for a particular client."""

    # Node for a particular client.
    node: "___api_v2_core__.Node" = betterproto.message_field(1)
    xds_config: List["PerXdsConfig"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ClientStatusResponse(betterproto.Message):
    # Client configs for the clients specified in the ClientStatusRequest.
    config: List["ClientConfig"] = betterproto.message_field(1)


class ClientStatusDiscoveryServiceStub(betterproto.ServiceStub):
    async def stream_client_status(
        self,
        request_iterator: Union[
            AsyncIterable["ClientStatusRequest"], Iterable["ClientStatusRequest"]
        ],
    ) -> AsyncIterator["ClientStatusResponse"]:

        async for response in self._stream_stream(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus",
            request_iterator,
            ClientStatusRequest,
            ClientStatusResponse,
        ):
            yield response

    async def fetch_client_status(
        self, *, node_matchers: Optional[List["___type_matcher__.NodeMatcher"]] = None
    ) -> "ClientStatusResponse":
        node_matchers = node_matchers or []

        request = ClientStatusRequest()
        if node_matchers is not None:
            request.node_matchers = node_matchers

        return await self._unary_unary(
            "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus",
            request,
            ClientStatusResponse,
        )


class ClientStatusDiscoveryServiceBase(ServiceBase):
    async def stream_client_status(
        self, request_iterator: AsyncIterator["ClientStatusRequest"]
    ) -> AsyncIterator["ClientStatusResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_client_status(
        self, node_matchers: Optional[List["___type_matcher__.NodeMatcher"]]
    ) -> "ClientStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_client_status(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        await self._call_rpc_handler_server_stream(
            self.stream_client_status,
            stream,
            request_kwargs,
        )

    async def __rpc_fetch_client_status(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "node_matchers": request.node_matchers,
        }

        response = await self.fetch_client_status(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus": grpclib.const.Handler(
                self.__rpc_stream_client_status,
                grpclib.const.Cardinality.STREAM_STREAM,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
            "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus": grpclib.const.Handler(
                self.__rpc_fetch_client_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClientStatusRequest,
                ClientStatusResponse,
            ),
        }


from ....admin import v2alpha as ___admin_v2_alpha__
from ....api.v2 import core as ___api_v2_core__
from ....type import matcher as ___type_matcher__
