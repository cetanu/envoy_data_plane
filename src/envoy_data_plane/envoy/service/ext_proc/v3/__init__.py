# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/ext_proc/v3/external_processor.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class CommonResponseResponseStatus(betterproto.Enum):
    CONTINUE = 0
    CONTINUE_AND_REPLACE = 1


@dataclass(eq=False, repr=False)
class ProcessingRequest(betterproto.Message):
    """
    This represents the different types of messages that Envoy can send to an
    external processing server. [#next-free-field: 8]
    """

    # Specify whether the filter that sent this request is running in synchronous
    # or asynchronous mode. The choice of synchronous or asynchronous mode can be
    # set in the filter configuration, and defaults to false. * A value of
    # "false" indicates that the server must respond   to this message by either
    # sending back a matching ProcessingResponse message,   or by closing the
    # stream. * A value of "true" indicates that the server must not respond to
    # this   message, although it may still close the stream to indicate that no
    # more messages   are needed.
    async_mode: bool = betterproto.bool_field(1)
    # Information about the HTTP request headers, as well as peer info and
    # additional properties. Unless "async_mode" is true, the server must send
    # back a HeaderResponse message, an ImmediateResponse message, or close the
    # stream.
    request_headers: "HttpHeaders" = betterproto.message_field(2, group="request")
    # Information about the HTTP response headers, as well as peer info and
    # additional properties. Unless "async_mode" is true, the server must send
    # back a HeaderResponse message or close the stream.
    response_headers: "HttpHeaders" = betterproto.message_field(3, group="request")
    # A chunk of the HTTP request body. Unless "async_mode" is true, the server
    # must send back a BodyResponse message, an ImmediateResponse message, or
    # close the stream.
    request_body: "HttpBody" = betterproto.message_field(4, group="request")
    # A chunk of the HTTP request body. Unless "async_mode" is true, the server
    # must send back a BodyResponse message or close the stream.
    response_body: "HttpBody" = betterproto.message_field(5, group="request")
    # The HTTP trailers for the request path. Unless "async_mode" is true, the
    # server must send back a TrailerResponse message or close the stream. This
    # message is only sent if the trailers processing mode is set to "SEND". If
    # there are no trailers on the original downstream request, then this message
    # will only be sent (with empty trailers waiting to be populated) if the
    # processing mode is set before the request headers are sent, such as in the
    # filter configuration.
    request_trailers: "HttpTrailers" = betterproto.message_field(6, group="request")
    # The HTTP trailers for the response path. Unless "async_mode" is true, the
    # server must send back a TrailerResponse message or close the stream. This
    # message is only sent if the trailers processing mode is set to "SEND". If
    # there are no trailers on the original downstream request, then this message
    # will only be sent (with empty trailers waiting to be populated) if the
    # processing mode is set before the request headers are sent, such as in the
    # filter configuration.
    response_trailers: "HttpTrailers" = betterproto.message_field(7, group="request")


@dataclass(eq=False, repr=False)
class ProcessingResponse(betterproto.Message):
    """
    For every ProcessingRequest received by the server with the "async_mode"
    field set to false, the server must send back exactly one
    ProcessingResponse message. [#next-free-field: 10]
    """

    # The server must send back this message in response to a message with the
    # "request_headers" field set.
    request_headers: "HeadersResponse" = betterproto.message_field(1, group="response")
    # The server must send back this message in response to a message with the
    # "response_headers" field set.
    response_headers: "HeadersResponse" = betterproto.message_field(2, group="response")
    # The server must send back this message in response to a message with the
    # "request_body" field set.
    request_body: "BodyResponse" = betterproto.message_field(3, group="response")
    # The server must send back this message in response to a message with the
    # "response_body" field set.
    response_body: "BodyResponse" = betterproto.message_field(4, group="response")
    # The server must send back this message in response to a message with the
    # "request_trailers" field set.
    request_trailers: "TrailersResponse" = betterproto.message_field(
        5, group="response"
    )
    # The server must send back this message in response to a message with the
    # "response_trailers" field set.
    response_trailers: "TrailersResponse" = betterproto.message_field(
        6, group="response"
    )
    # If specified, attempt to create a locally generated response, send it
    # downstream, and stop processing additional filters and ignore any
    # additional messages received from the remote server for this request or
    # response. If a response has already started -- for example, if this message
    # is sent response to a "response_body" message -- then this will either ship
    # the reply directly to the downstream codec, or reset the stream.
    immediate_response: "ImmediateResponse" = betterproto.message_field(
        7, group="response"
    )
    # [#not-implemented-hide:] Optional metadata that will be emitted as dynamic
    # metadata to be consumed by the next filter. This metadata will be placed in
    # the namespace "envoy.filters.http.ext_proc".
    dynamic_metadata: "betterproto_lib_google_protobuf.Struct" = (
        betterproto.message_field(8)
    )
    # Override how parts of the HTTP request and response are processed for the
    # duration of this particular request/response only. Servers may use this to
    # intelligently control how requests are processed based on the headers and
    # other metadata that they see.
    mode_override: "___extensions_filters_http_ext_proc_v3__.ProcessingMode" = (
        betterproto.message_field(9)
    )


@dataclass(eq=False, repr=False)
class HttpHeaders(betterproto.Message):
    """
    This message is sent to the external server when the HTTP request and
    responses are first received.
    """

    # The HTTP request headers. All header keys will be lower-cased, because HTTP
    # header keys are case-insensitive.
    headers: "___config_core_v3__.HeaderMap" = betterproto.message_field(1)
    # [#not-implemented-hide:] The values of properties selected by the
    # "request_attributes" or "response_attributes" list in the configuration.
    # Each entry in the list is populated from the standard :ref:`attributes
    # <arch_overview_attributes>` supported across Envoy.
    attributes: Dict[
        str, "betterproto_lib_google_protobuf.Struct"
    ] = betterproto.map_field(2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    # If true, then there is no message body associated with this request or
    # response.
    end_of_stream: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class HttpBody(betterproto.Message):
    """
    This message contains the message body that Envoy sends to the external
    server.
    """

    body: bytes = betterproto.bytes_field(1)
    end_of_stream: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class HttpTrailers(betterproto.Message):
    """This message contains the trailers."""

    trailers: "___config_core_v3__.HeaderMap" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class HeadersResponse(betterproto.Message):
    """This message must be sent in response to an HttpHeaders message."""

    response: "CommonResponse" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class TrailersResponse(betterproto.Message):
    """This message must be sent in response to an HttpTrailers message."""

    # Instructions on how to manipulate the trailers
    header_mutation: "HeaderMutation" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BodyResponse(betterproto.Message):
    """This message must be sent in response to an HttpBody message."""

    response: "CommonResponse" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CommonResponse(betterproto.Message):
    """
    This message contains common fields between header and body responses.
    [#next-free-field: 6]
    """

    # If set, provide additional direction on how the Envoy proxy should handle
    # the rest of the HTTP filter chain.
    status: "CommonResponseResponseStatus" = betterproto.enum_field(1)
    # Instructions on how to manipulate the headers. When responding to an
    # HttpBody request, header mutations will only take effect if the current
    # processing mode for the body is BUFFERED.
    header_mutation: "HeaderMutation" = betterproto.message_field(2)
    # Replace the body of the last message sent to the remote server on this
    # stream. If responding to an HttpBody request, simply replace or clear the
    # body chunk that was sent with that request. Body mutations only take effect
    # in response to "body" messages and are ignored otherwise.
    body_mutation: "BodyMutation" = betterproto.message_field(3)
    # [#not-implemented-hide:] Add new trailers to the message. This may be used
    # when responding to either a HttpHeaders or HttpBody message, but only if
    # this message is returned along with the CONTINUE_AND_REPLACE status.
    trailers: "___config_core_v3__.HeaderMap" = betterproto.message_field(4)
    # Clear the route cache for the current request. This is necessary if the
    # remote server modified headers that are used to calculate the route.
    clear_route_cache: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class ImmediateResponse(betterproto.Message):
    """
    This message causes the filter to attempt to create a locally generated
    response, send it  downstream, stop processing additional filters, and
    ignore any additional messages received from the remote server for this
    request or response. If a response has already started, then  this will
    either ship the reply directly to the downstream codec, or reset the
    stream. [#next-free-field: 6]
    """

    # The response code to return
    status: "___type_v3__.HttpStatus" = betterproto.message_field(1)
    # Apply changes to the default headers, which will include content-type.
    headers: "HeaderMutation" = betterproto.message_field(2)
    # The message body to return with the response which is sent using the
    # text/plain content type, or encoded in the grpc-message header.
    body: str = betterproto.string_field(3)
    # If set, then include a gRPC status trailer.
    grpc_status: "GrpcStatus" = betterproto.message_field(4)
    # A string detailing why this local reply was sent, which may be included in
    # log and debug output.
    details: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class GrpcStatus(betterproto.Message):
    """
    This message specifies a gRPC status for an ImmediateResponse message.
    """

    # The actual gRPC status
    status: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class HeaderMutation(betterproto.Message):
    """
    Change HTTP headers or trailers by appending, replacing, or removing
    headers.
    """

    # Add or replace HTTP headers. Attempts to set the value of any "x-envoy"
    # header, and attempts to set the ":method", ":authority", ":scheme", or
    # "host" headers will be ignored.
    set_headers: List[
        "___config_core_v3__.HeaderValueOption"
    ] = betterproto.message_field(1)
    # Remove these HTTP headers. Attempts to remove system headers -- any header
    # starting with ":", plus "host" -- will be ignored.
    remove_headers: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BodyMutation(betterproto.Message):
    """
    Replace the entire message body chunk received in the corresponding
    HttpBody message with this new body, or clear the body.
    """

    # The entire body to replace
    body: bytes = betterproto.bytes_field(1, group="mutation")
    # Clear the corresponding body chunk
    clear_body: bool = betterproto.bool_field(2, group="mutation")


class ExternalProcessorStub(betterproto.ServiceStub):
    async def process(
        self,
        request_iterator: Union[
            AsyncIterable["ProcessingRequest"], Iterable["ProcessingRequest"]
        ],
    ) -> AsyncIterator["ProcessingResponse"]:

        async for response in self._stream_stream(
            "/envoy.service.ext_proc.v3.ExternalProcessor/Process",
            request_iterator,
            ProcessingRequest,
            ProcessingResponse,
        ):
            yield response


class ExternalProcessorBase(ServiceBase):
    async def process(
        self, request_iterator: AsyncIterator["ProcessingRequest"]
    ) -> AsyncIterator["ProcessingResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_process(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        await self._call_rpc_handler_server_stream(
            self.process,
            stream,
            request_kwargs,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/envoy.service.ext_proc.v3.ExternalProcessor/Process": grpclib.const.Handler(
                self.__rpc_process,
                grpclib.const.Cardinality.STREAM_STREAM,
                ProcessingRequest,
                ProcessingResponse,
            ),
        }


from ....config.core import v3 as ___config_core_v3__
from ....extensions.filters.http.ext_proc import (
    v3 as ___extensions_filters_http_ext_proc_v3__,
)
from ....type import v3 as ___type_v3__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
