# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/health/v4alpha/hds.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class CapabilityProtocol(betterproto.Enum):
    HTTP = 0
    TCP = 1
    REDIS = 2


@dataclass(eq=False, repr=False)
class Capability(betterproto.Message):
    """
    Defines supported protocols etc, so the management server can assign proper
    endpoints to healthcheck.
    """

    health_check_protocols: List["CapabilityProtocol"] = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class HealthCheckRequest(betterproto.Message):
    node: "___config_core_v4_alpha__.Node" = betterproto.message_field(1)
    capability: "Capability" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EndpointHealth(betterproto.Message):
    endpoint: "___config_endpoint_v3__.Endpoint" = betterproto.message_field(1)
    health_status: "___config_core_v4_alpha__.HealthStatus" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class LocalityEndpointsHealth(betterproto.Message):
    """Group endpoint health by locality under each cluster."""

    locality: "___config_core_v4_alpha__.Locality" = betterproto.message_field(1)
    endpoints_health: List["EndpointHealth"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ClusterEndpointsHealth(betterproto.Message):
    """
    The health status of endpoints in a cluster. The cluster name and locality
    should match the corresponding fields in ClusterHealthCheck message.
    """

    cluster_name: str = betterproto.string_field(1)
    locality_endpoints_health: List[
        "LocalityEndpointsHealth"
    ] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EndpointHealthResponse(betterproto.Message):
    # Organize Endpoint health information by cluster.
    cluster_endpoints_health: List[
        "ClusterEndpointsHealth"
    ] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class HealthCheckRequestOrEndpointHealthResponse(betterproto.Message):
    health_check_request: "HealthCheckRequest" = betterproto.message_field(
        1, group="request_type"
    )
    endpoint_health_response: "EndpointHealthResponse" = betterproto.message_field(
        2, group="request_type"
    )


@dataclass(eq=False, repr=False)
class LocalityEndpoints(betterproto.Message):
    locality: "___config_core_v4_alpha__.Locality" = betterproto.message_field(1)
    endpoints: List["___config_endpoint_v3__.Endpoint"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ClusterHealthCheck(betterproto.Message):
    """
    The cluster name and locality is provided to Envoy for the endpoints that
    it health checks to support statistics reporting, logging and debugging by
    the Envoy instance (outside of HDS). For maximum usefulness, it should
    match the same cluster structure as that provided by EDS.
    """

    cluster_name: str = betterproto.string_field(1)
    health_checks: List[
        "___config_core_v4_alpha__.HealthCheck"
    ] = betterproto.message_field(2)
    locality_endpoints: List["LocalityEndpoints"] = betterproto.message_field(3)
    # Optional map that gets filtered by
    # :ref:`health_checks.transport_socket_match_criteria <envoy_api_field_config
    # .core.v4alpha.HealthCheck.transport_socket_match_criteria>` on connection
    # when health checking. For more details, see
    # :ref:`config.cluster.v3.Cluster.transport_socket_matches
    # <envoy_api_field_config.cluster.v4alpha.Cluster.transport_socket_matches>`.
    transport_socket_matches: List[
        "___config_cluster_v4_alpha__.ClusterTransportSocketMatch"
    ] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class HealthCheckSpecifier(betterproto.Message):
    cluster_health_checks: List["ClusterHealthCheck"] = betterproto.message_field(1)
    # The default is 1 second.
    interval: timedelta = betterproto.message_field(2)


class HealthDiscoveryServiceStub(betterproto.ServiceStub):
    async def stream_health_check(
        self,
        request_iterator: Union[
            AsyncIterable["HealthCheckRequestOrEndpointHealthResponse"],
            Iterable["HealthCheckRequestOrEndpointHealthResponse"],
        ],
    ) -> AsyncIterator["HealthCheckSpecifier"]:

        async for response in self._stream_stream(
            "/envoy.service.health.v4alpha.HealthDiscoveryService/StreamHealthCheck",
            request_iterator,
            HealthCheckRequestOrEndpointHealthResponse,
            HealthCheckSpecifier,
        ):
            yield response

    async def fetch_health_check(
        self,
        *,
        health_check_request: "HealthCheckRequest" = None,
        endpoint_health_response: "EndpointHealthResponse" = None,
    ) -> "HealthCheckSpecifier":

        request = HealthCheckRequestOrEndpointHealthResponse()
        if health_check_request is not None:
            request.health_check_request = health_check_request
        if endpoint_health_response is not None:
            request.endpoint_health_response = endpoint_health_response

        return await self._unary_unary(
            "/envoy.service.health.v4alpha.HealthDiscoveryService/FetchHealthCheck",
            request,
            HealthCheckSpecifier,
        )


class HealthDiscoveryServiceBase(ServiceBase):
    async def stream_health_check(
        self,
        request_iterator: AsyncIterator["HealthCheckRequestOrEndpointHealthResponse"],
    ) -> AsyncIterator["HealthCheckSpecifier"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_health_check(
        self,
        health_check_request: "HealthCheckRequest",
        endpoint_health_response: "EndpointHealthResponse",
    ) -> "HealthCheckSpecifier":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_health_check(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        await self._call_rpc_handler_server_stream(
            self.stream_health_check,
            stream,
            request_kwargs,
        )

    async def __rpc_fetch_health_check(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "health_check_request": request.health_check_request,
            "endpoint_health_response": request.endpoint_health_response,
        }

        response = await self.fetch_health_check(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/envoy.service.health.v4alpha.HealthDiscoveryService/StreamHealthCheck": grpclib.const.Handler(
                self.__rpc_stream_health_check,
                grpclib.const.Cardinality.STREAM_STREAM,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
            "/envoy.service.health.v4alpha.HealthDiscoveryService/FetchHealthCheck": grpclib.const.Handler(
                self.__rpc_fetch_health_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                HealthCheckRequestOrEndpointHealthResponse,
                HealthCheckSpecifier,
            ),
        }


from ....config.cluster import v4alpha as ___config_cluster_v4_alpha__
from ....config.core import v4alpha as ___config_core_v4_alpha__
from ....config.endpoint import v3 as ___config_endpoint_v3__
