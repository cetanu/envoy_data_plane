# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/filter/http/adaptive_concurrency/v2alpha/adaptive_concurrency.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase


@dataclass(eq=False, repr=False)
class GradientControllerConfig(betterproto.Message):
    """Configuration parameters for the gradient controller."""

    # The percentile to use when summarizing aggregated samples. Defaults to p50.
    sample_aggregate_percentile: "_____type__.Percent" = betterproto.message_field(1)
    concurrency_limit_params: "GradientControllerConfigConcurrencyLimitCalculationParams" = betterproto.message_field(
        2
    )
    min_rtt_calc_params: "GradientControllerConfigMinimumRttCalculationParams" = (
        betterproto.message_field(3)
    )


@dataclass(eq=False, repr=False)
class GradientControllerConfigConcurrencyLimitCalculationParams(betterproto.Message):
    """
    Parameters controlling the periodic recalculation of the concurrency limit
    from sampled request latencies.
    """

    # The allowed upper-bound on the calculated concurrency limit. Defaults to
    # 1000.
    max_concurrency_limit: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    # The period of time samples are taken to recalculate the concurrency limit.
    concurrency_update_interval: timedelta = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class GradientControllerConfigMinimumRttCalculationParams(betterproto.Message):
    """
    Parameters controlling the periodic minRTT recalculation. [#next-free-
    field: 6]
    """

    # The time interval between recalculating the minimum request round-trip
    # time.
    interval: timedelta = betterproto.message_field(1)
    # The number of requests to aggregate/sample during the minRTT recalculation
    # window before updating. Defaults to 50.
    request_count: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    # Randomized time delta that will be introduced to the start of the minRTT
    # calculation window. This is represented as a percentage of the interval
    # duration. Defaults to 15%. Example: If the interval is 10s and the jitter
    # is 15%, the next window will begin somewhere in the range (10s - 11.5s).
    jitter: "_____type__.Percent" = betterproto.message_field(3)
    # The concurrency limit set while measuring the minRTT. Defaults to 3.
    min_concurrency: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    # Amount added to the measured minRTT to add stability to the concurrency
    # limit during natural variability in latency. This is expressed as a
    # percentage of the measured value and can be adjusted to allow more or less
    # tolerance to the sampled latency values. Defaults to 25%.
    buffer: "_____type__.Percent" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class AdaptiveConcurrency(betterproto.Message):
    # Gradient concurrency control will be used.
    gradient_controller_config: "GradientControllerConfig" = betterproto.message_field(
        1, group="concurrency_controller_config"
    )
    # If set to false, the adaptive concurrency filter will operate as a pass-
    # through filter. If the message is unspecified, the filter will be enabled.
    enabled: "_____api_v2_core__.RuntimeFeatureFlag" = betterproto.message_field(2)


from ...... import type as _____type__
from ......api.v2 import core as _____api_v2_core__
