# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/admin/v2alpha/certs.proto, envoy/admin/v2alpha/clusters.proto, envoy/admin/v2alpha/config_dump.proto, envoy/admin/v2alpha/listeners.proto, envoy/admin/v2alpha/memory.proto, envoy/admin/v2alpha/metrics.proto, envoy/admin/v2alpha/mutex_stats.proto, envoy/admin/v2alpha/server_info.proto, envoy/admin/v2alpha/tap.proto
# plugin: python-betterproto
import warnings
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase


class SimpleMetricType(betterproto.Enum):
    COUNTER = 0
    GAUGE = 1


class ServerInfoState(betterproto.Enum):
    LIVE = 0
    DRAINING = 1
    PRE_INITIALIZING = 2
    INITIALIZING = 3


class CommandLineOptionsIpVersion(betterproto.Enum):
    v4 = 0
    v6 = 1


class CommandLineOptionsMode(betterproto.Enum):
    Serve = 0
    Validate = 1
    InitOnly = 2


@dataclass(eq=False, repr=False)
class MutexStats(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    num_contentions: int = betterproto.uint64_field(1)
    # The length of the current contention wait cycle.
    current_wait_cycles: int = betterproto.uint64_field(2)
    # The lifetime total of all contention wait cycles.
    lifetime_wait_cycles: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class SimpleMetric(betterproto.Message):
    """Proto representation of an Envoy Counter or Gauge value."""

    # Type of the metric represented.
    type: "SimpleMetricType" = betterproto.enum_field(1)
    # Current metric value.
    value: int = betterproto.uint64_field(2)
    # Name of the metric.
    name: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Clusters(betterproto.Message):
    """
    Admin endpoint uses this wrapper for `/clusters` to display cluster status
    information. See :ref:`/clusters <operations_admin_interface_clusters>` for
    more information.
    """

    # Mapping from cluster name to each cluster's status.
    cluster_statuses: List["ClusterStatus"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ClusterStatus(betterproto.Message):
    """
    Details an individual cluster's current status. [#next-free-field: 6]
    """

    # Name of the cluster.
    name: str = betterproto.string_field(1)
    # Denotes whether this cluster was added via API or configured statically.
    added_via_api: bool = betterproto.bool_field(2)
    # The success rate threshold used in the last interval. If :ref:`outlier_dete
    # ction.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDet
    # ection.split_external_local_origin_errors>` is *false*, all errors:
    # externally and locally generated were used to calculate the threshold. If :
    # ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_c
    # luster.OutlierDetection.split_external_local_origin_errors>` is *true*,
    # only externally generated errors were used to calculate the threshold. The
    # threshold is used to eject hosts based on their success rate. See
    # :ref:`Cluster outlier detection <arch_overview_outlier_detection>`
    # documentation for details. Note: this field may be omitted in any of the
    # three following cases: 1. There were not enough hosts with enough request
    # volume to proceed with success rate based    outlier ejection. 2. The
    # threshold is computed to be < 0 because a negative value implies that there
    # was no    threshold for that interval. 3. Outlier detection is not enabled
    # for this cluster.
    success_rate_ejection_threshold: "__type__.Percent" = betterproto.message_field(3)
    # Mapping from host address to the host's current status.
    host_statuses: List["HostStatus"] = betterproto.message_field(4)
    # The success rate threshold used in the last interval when only locally
    # originated failures were taken into account and externally originated
    # errors were treated as success. This field should be interpreted only when
    # :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_
    # cluster.OutlierDetection.split_external_local_origin_errors>` is *true*.
    # The threshold is used to eject hosts based on their success rate. See
    # :ref:`Cluster outlier detection <arch_overview_outlier_detection>`
    # documentation for details. Note: this field may be omitted in any of the
    # three following cases: 1. There were not enough hosts with enough request
    # volume to proceed with success rate based    outlier ejection. 2. The
    # threshold is computed to be < 0 because a negative value implies that there
    # was no    threshold for that interval. 3. Outlier detection is not enabled
    # for this cluster.
    local_origin_success_rate_ejection_threshold: "__type__.Percent" = (
        betterproto.message_field(5)
    )


@dataclass(eq=False, repr=False)
class HostStatus(betterproto.Message):
    """Current state of a particular host. [#next-free-field: 10]"""

    # Address of this host.
    address: "__api_v2_core__.Address" = betterproto.message_field(1)
    # List of stats specific to this host.
    stats: List["SimpleMetric"] = betterproto.message_field(2)
    # The host's current health status.
    health_status: "HostHealthStatus" = betterproto.message_field(3)
    # Request success rate for this host over the last calculated interval. If :r
    # ef:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cl
    # uster.OutlierDetection.split_external_local_origin_errors>` is *false*, all
    # errors: externally and locally generated were used in success rate
    # calculation. If :ref:`outlier_detection.split_external_local_origin_errors<
    # envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors
    # >` is *true*, only externally generated errors were used in success rate
    # calculation. See :ref:`Cluster outlier detection
    # <arch_overview_outlier_detection>` documentation for details. Note: the
    # message will not be present if host did not have enough request volume to
    # calculate success rate or the cluster did not have enough hosts to run
    # through success rate outlier ejection.
    success_rate: "__type__.Percent" = betterproto.message_field(4)
    # The host's weight. If not configured, the value defaults to 1.
    weight: int = betterproto.uint32_field(5)
    # The hostname of the host, if applicable.
    hostname: str = betterproto.string_field(6)
    # The host's priority. If not configured, the value defaults to 0 (highest
    # priority).
    priority: int = betterproto.uint32_field(7)
    # Request success rate for this host over the last calculated interval when
    # only locally originated errors are taken into account and externally
    # originated errors were treated as success. This field should be interpreted
    # only when :ref:`outlier_detection.split_external_local_origin_errors<envoy_
    # api_field_cluster.OutlierDetection.split_external_local_origin_errors>` is
    # *true*. See :ref:`Cluster outlier detection
    # <arch_overview_outlier_detection>` documentation for details. Note: the
    # message will not be present if host did not have enough request volume to
    # calculate success rate or the cluster did not have enough hosts to run
    # through success rate outlier ejection.
    local_origin_success_rate: "__type__.Percent" = betterproto.message_field(8)
    # locality of the host.
    locality: "__api_v2_core__.Locality" = betterproto.message_field(9)


@dataclass(eq=False, repr=False)
class HostHealthStatus(betterproto.Message):
    """Health status for a host. [#next-free-field: 7]"""

    # The host is currently failing active health checks.
    failed_active_health_check: bool = betterproto.bool_field(1)
    # The host is currently considered an outlier and has been ejected.
    failed_outlier_check: bool = betterproto.bool_field(2)
    # The host is currently being marked as degraded through active health
    # checking.
    failed_active_degraded_check: bool = betterproto.bool_field(4)
    # The host has been removed from service discovery, but is being stabilized
    # due to active health checking.
    pending_dynamic_removal: bool = betterproto.bool_field(5)
    # The host has not yet been health checked.
    pending_active_hc: bool = betterproto.bool_field(6)
    # Health status as reported by EDS. Note: only HEALTHY and UNHEALTHY are
    # currently supported here. [#comment:TODO(mrice32): pipe through remaining
    # EDS health status possibilities.]
    eds_health_status: "__api_v2_core__.HealthStatus" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Memory(betterproto.Message):
    """
    Proto representation of the internal memory consumption of an Envoy
    instance. These represent values extracted from an internal TCMalloc
    instance. For more information, see the section of the docs entitled
    ["Generic Tcmalloc
    Status"](https://gperftools.github.io/gperftools/tcmalloc.html). [#next-
    free-field: 7]
    """

    # The number of bytes allocated by the heap for Envoy. This is an alias for
    # `generic.current_allocated_bytes`.
    allocated: int = betterproto.uint64_field(1)
    # The number of bytes reserved by the heap but not necessarily allocated.
    # This is an alias for `generic.heap_size`.
    heap_size: int = betterproto.uint64_field(2)
    # The number of bytes in free, unmapped pages in the page heap. These bytes
    # always count towards virtual memory usage, and depending on the OS,
    # typically do not count towards physical memory usage. This is an alias for
    # `tcmalloc.pageheap_unmapped_bytes`.
    pageheap_unmapped: int = betterproto.uint64_field(3)
    # The number of bytes in free, mapped pages in the page heap. These bytes
    # always count towards virtual memory usage, and unless the underlying memory
    # is swapped out by the OS, they also count towards physical memory usage.
    # This is an alias for `tcmalloc.pageheap_free_bytes`.
    pageheap_free: int = betterproto.uint64_field(4)
    # The amount of memory used by the TCMalloc thread caches (for small
    # objects). This is an alias for `tcmalloc.current_total_thread_cache_bytes`.
    total_thread_cache: int = betterproto.uint64_field(5)
    # The number of bytes of the physical memory usage by the allocator. This is
    # an alias for `generic.total_physical_bytes`.
    total_physical_bytes: int = betterproto.uint64_field(6)


@dataclass(eq=False, repr=False)
class ConfigDump(betterproto.Message):
    """
    The :ref:`/config_dump <operations_admin_interface_config_dump>` admin
    endpoint uses this wrapper message to maintain and serve arbitrary
    configuration information from any component in Envoy.
    """

    # This list is serialized and dumped in its entirety at the
    # :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint. The
    # following configurations are currently supported and will be dumped in the
    # order given below: * *bootstrap*: :ref:`BootstrapConfigDump
    # <envoy_api_msg_admin.v2alpha.BootstrapConfigDump>` * *clusters*:
    # :ref:`ClustersConfigDump <envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
    # * *listeners*: :ref:`ListenersConfigDump
    # <envoy_api_msg_admin.v2alpha.ListenersConfigDump>` * *routes*:
    # :ref:`RoutesConfigDump <envoy_api_msg_admin.v2alpha.RoutesConfigDump>` You
    # can filter output with the resource and mask query parameters. See
    # :ref:`/config_dump?resource={}
    # <operations_admin_interface_config_dump_by_resource>`,
    # :ref:`/config_dump?mask={}
    # <operations_admin_interface_config_dump_by_mask>`, or
    # :ref:`/config_dump?resource={},mask={}
    # <operations_admin_interface_config_dump_by_resource_and_mask>` for more
    # information.
    configs: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateFailureState(betterproto.Message):
    # What the component configuration would have been if the update had
    # succeeded.
    failed_configuration: "betterproto_lib_google_protobuf.Any" = (
        betterproto.message_field(1)
    )
    # Time of the latest failed update attempt.
    last_update_attempt: datetime = betterproto.message_field(2)
    # Details about the last failed update attempt.
    details: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class BootstrapConfigDump(betterproto.Message):
    """
    This message describes the bootstrap configuration that Envoy was started
    with. This includes any CLI overrides that were merged. Bootstrap
    configuration information can be used to recreate the static portions of an
    Envoy configuration by reusing the output as the bootstrap configuration
    for another Envoy.
    """

    bootstrap: "__config_bootstrap_v2__.Bootstrap" = betterproto.message_field(1)
    # The timestamp when the BootstrapConfig was last updated.
    last_updated: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ListenersConfigDump(betterproto.Message):
    """
    Envoy's listener manager fills this message with all currently known
    listeners. Listener configuration information can be used to recreate an
    Envoy configuration by populating all listeners as static listeners or by
    returning them in a LDS response.
    """

    # This is the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` in the last processed LDS
    # discovery response. If there are only static bootstrap listeners, this
    # field will be "".
    version_info: str = betterproto.string_field(1)
    # The statically loaded listener configs.
    static_listeners: List[
        "ListenersConfigDumpStaticListener"
    ] = betterproto.message_field(2)
    # State for any warming, active, or draining listeners.
    dynamic_listeners: List[
        "ListenersConfigDumpDynamicListener"
    ] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ListenersConfigDumpStaticListener(betterproto.Message):
    """Describes a statically loaded listener."""

    # The listener config.
    listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    # The timestamp when the Listener was last successfully updated.
    last_updated: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ListenersConfigDumpDynamicListenerState(betterproto.Message):
    # This is the per-resource version information. This version is currently
    # taken from the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    # the listener was loaded. In the future, discrete per-listener versions may
    # be supported by the API.
    version_info: str = betterproto.string_field(1)
    # The listener config.
    listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    # The timestamp when the Listener was last successfully updated.
    last_updated: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ListenersConfigDumpDynamicListener(betterproto.Message):
    """
    Describes a dynamically loaded listener via the LDS API. [#next-free-field:
    6]
    """

    # The name or unique id of this listener, pulled from the
    # DynamicListenerState config.
    name: str = betterproto.string_field(1)
    # The listener state for any active listener by this name. These are
    # listeners that are available to service data plane traffic.
    active_state: "ListenersConfigDumpDynamicListenerState" = betterproto.message_field(
        2
    )
    # The listener state for any warming listener by this name. These are
    # listeners that are currently undergoing warming in preparation to service
    # data plane traffic. Note that if attempting to recreate an Envoy
    # configuration from a configuration dump, the warming listeners should
    # generally be discarded.
    warming_state: "ListenersConfigDumpDynamicListenerState" = (
        betterproto.message_field(3)
    )
    # The listener state for any draining listener by this name. These are
    # listeners that are currently undergoing draining in preparation to stop
    # servicing data plane traffic. Note that if attempting to recreate an Envoy
    # configuration from a configuration dump, the draining listeners should
    # generally be discarded.
    draining_state: "ListenersConfigDumpDynamicListenerState" = (
        betterproto.message_field(4)
    )
    # Set if the last update failed, cleared after the next successful update.
    error_state: "UpdateFailureState" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class ClustersConfigDump(betterproto.Message):
    """
    Envoy's cluster manager fills this message with all currently known
    clusters. Cluster configuration information can be used to recreate an
    Envoy configuration by populating all clusters as static clusters or by
    returning them in a CDS response.
    """

    # This is the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` in the last processed CDS
    # discovery response. If there are only static bootstrap clusters, this field
    # will be "".
    version_info: str = betterproto.string_field(1)
    # The statically loaded cluster configs.
    static_clusters: List[
        "ClustersConfigDumpStaticCluster"
    ] = betterproto.message_field(2)
    # The dynamically loaded active clusters. These are clusters that are
    # available to service data plane traffic.
    dynamic_active_clusters: List[
        "ClustersConfigDumpDynamicCluster"
    ] = betterproto.message_field(3)
    # The dynamically loaded warming clusters. These are clusters that are
    # currently undergoing warming in preparation to service data plane traffic.
    # Note that if attempting to recreate an Envoy configuration from a
    # configuration dump, the warming clusters should generally be discarded.
    dynamic_warming_clusters: List[
        "ClustersConfigDumpDynamicCluster"
    ] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class ClustersConfigDumpStaticCluster(betterproto.Message):
    """Describes a statically loaded cluster."""

    # The cluster config.
    cluster: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    # The timestamp when the Cluster was last updated.
    last_updated: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ClustersConfigDumpDynamicCluster(betterproto.Message):
    """Describes a dynamically loaded cluster via the CDS API."""

    # This is the per-resource version information. This version is currently
    # taken from the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    # the cluster was loaded. In the future, discrete per-cluster versions may be
    # supported by the API.
    version_info: str = betterproto.string_field(1)
    # The cluster config.
    cluster: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    # The timestamp when the Cluster was last updated.
    last_updated: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class RoutesConfigDump(betterproto.Message):
    """
    Envoy's RDS implementation fills this message with all currently loaded
    routes, as described by their RouteConfiguration objects. Static routes
    that are either defined in the bootstrap configuration or defined inline
    while configuring listeners are separated from those configured dynamically
    via RDS. Route configuration information can be used to recreate an Envoy
    configuration by populating all routes as static routes or by returning
    them in RDS responses.
    """

    # The statically loaded route configs.
    static_route_configs: List[
        "RoutesConfigDumpStaticRouteConfig"
    ] = betterproto.message_field(2)
    # The dynamically loaded route configs.
    dynamic_route_configs: List[
        "RoutesConfigDumpDynamicRouteConfig"
    ] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class RoutesConfigDumpStaticRouteConfig(betterproto.Message):
    # The route config.
    route_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    # The timestamp when the Route was last updated.
    last_updated: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RoutesConfigDumpDynamicRouteConfig(betterproto.Message):
    # This is the per-resource version information. This version is currently
    # taken from the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    # the route configuration was loaded.
    version_info: str = betterproto.string_field(1)
    # The route config.
    route_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    # The timestamp when the Route was last updated.
    last_updated: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDump(betterproto.Message):
    """
    Envoy's scoped RDS implementation fills this message with all currently
    loaded route configuration scopes (defined via ScopedRouteConfigurationsSet
    protos). This message lists both the scopes defined inline with the higher
    order object (i.e., the HttpConnectionManager) and the dynamically obtained
    scopes via the SRDS API.
    """

    # The statically loaded scoped route configs.
    inline_scoped_route_configs: List[
        "ScopedRoutesConfigDumpInlineScopedRouteConfigs"
    ] = betterproto.message_field(1)
    # The dynamically loaded scoped route configs.
    dynamic_scoped_route_configs: List[
        "ScopedRoutesConfigDumpDynamicScopedRouteConfigs"
    ] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDumpInlineScopedRouteConfigs(betterproto.Message):
    # The name assigned to the scoped route configurations.
    name: str = betterproto.string_field(1)
    # The scoped route configurations.
    scoped_route_configs: List[
        "betterproto_lib_google_protobuf.Any"
    ] = betterproto.message_field(2)
    # The timestamp when the scoped route config set was last updated.
    last_updated: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDumpDynamicScopedRouteConfigs(betterproto.Message):
    # The name assigned to the scoped route configurations.
    name: str = betterproto.string_field(1)
    # This is the per-resource version information. This version is currently
    # taken from the :ref:`version_info
    # <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    # the scoped routes configuration was loaded.
    version_info: str = betterproto.string_field(2)
    # The scoped route configurations.
    scoped_route_configs: List[
        "betterproto_lib_google_protobuf.Any"
    ] = betterproto.message_field(3)
    # The timestamp when the scoped route config set was last updated.
    last_updated: datetime = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class SecretsConfigDump(betterproto.Message):
    """
    Envoys SDS implementation fills this message with all secrets fetched
    dynamically via SDS.
    """

    # The statically loaded secrets.
    static_secrets: List["SecretsConfigDumpStaticSecret"] = betterproto.message_field(1)
    # The dynamically loaded active secrets. These are secrets that are available
    # to service clusters or listeners.
    dynamic_active_secrets: List[
        "SecretsConfigDumpDynamicSecret"
    ] = betterproto.message_field(2)
    # The dynamically loaded warming secrets. These are secrets that are
    # currently undergoing warming in preparation to service clusters or
    # listeners.
    dynamic_warming_secrets: List[
        "SecretsConfigDumpDynamicSecret"
    ] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class SecretsConfigDumpDynamicSecret(betterproto.Message):
    """DynamicSecret contains secret information fetched via SDS."""

    # The name assigned to the secret.
    name: str = betterproto.string_field(1)
    # This is the per-resource version information.
    version_info: str = betterproto.string_field(2)
    # The timestamp when the secret was last updated.
    last_updated: datetime = betterproto.message_field(3)
    # The actual secret information. Security sensitive information is redacted
    # (replaced with "[redacted]") for private keys and passwords in TLS
    # certificates.
    secret: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class SecretsConfigDumpStaticSecret(betterproto.Message):
    """StaticSecret specifies statically loaded secret in bootstrap."""

    # The name assigned to the secret.
    name: str = betterproto.string_field(1)
    # The timestamp when the secret was last updated.
    last_updated: datetime = betterproto.message_field(2)
    # The actual secret information. Security sensitive information is redacted
    # (replaced with "[redacted]") for private keys and passwords in TLS
    # certificates.
    secret: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ServerInfo(betterproto.Message):
    """
    Proto representation of the value returned by /server_info, containing
    server version/server status information. [#next-free-field: 7]
    """

    # Server version.
    version: str = betterproto.string_field(1)
    # State of the server.
    state: "ServerInfoState" = betterproto.enum_field(2)
    # Uptime since current epoch was started.
    uptime_current_epoch: timedelta = betterproto.message_field(3)
    # Uptime since the start of the first epoch.
    uptime_all_epochs: timedelta = betterproto.message_field(4)
    # Hot restart version.
    hot_restart_version: str = betterproto.string_field(5)
    # Command line options the server is currently running with.
    command_line_options: "CommandLineOptions" = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class CommandLineOptions(betterproto.Message):
    """[#next-free-field: 29]"""

    # See :option:`--base-id` for details.
    base_id: int = betterproto.uint64_field(1)
    # See :option:`--concurrency` for details.
    concurrency: int = betterproto.uint32_field(2)
    # See :option:`--config-path` for details.
    config_path: str = betterproto.string_field(3)
    # See :option:`--config-yaml` for details.
    config_yaml: str = betterproto.string_field(4)
    # See :option:`--allow-unknown-static-fields` for details.
    allow_unknown_static_fields: bool = betterproto.bool_field(5)
    # See :option:`--reject-unknown-dynamic-fields` for details.
    reject_unknown_dynamic_fields: bool = betterproto.bool_field(26)
    # See :option:`--admin-address-path` for details.
    admin_address_path: str = betterproto.string_field(6)
    # See :option:`--local-address-ip-version` for details.
    local_address_ip_version: "CommandLineOptionsIpVersion" = betterproto.enum_field(7)
    # See :option:`--log-level` for details.
    log_level: str = betterproto.string_field(8)
    # See :option:`--component-log-level` for details.
    component_log_level: str = betterproto.string_field(9)
    # See :option:`--log-format` for details.
    log_format: str = betterproto.string_field(10)
    # See :option:`--log-format-escaped` for details.
    log_format_escaped: bool = betterproto.bool_field(27)
    # See :option:`--log-path` for details.
    log_path: str = betterproto.string_field(11)
    # See :option:`--service-cluster` for details.
    service_cluster: str = betterproto.string_field(13)
    # See :option:`--service-node` for details.
    service_node: str = betterproto.string_field(14)
    # See :option:`--service-zone` for details.
    service_zone: str = betterproto.string_field(15)
    # See :option:`--file-flush-interval-msec` for details.
    file_flush_interval: timedelta = betterproto.message_field(16)
    # See :option:`--drain-time-s` for details.
    drain_time: timedelta = betterproto.message_field(17)
    # See :option:`--parent-shutdown-time-s` for details.
    parent_shutdown_time: timedelta = betterproto.message_field(18)
    # See :option:`--mode` for details.
    mode: "CommandLineOptionsMode" = betterproto.enum_field(19)
    # max_stats and max_obj_name_len are now unused and have no effect.
    max_stats: int = betterproto.uint64_field(20)
    max_obj_name_len: int = betterproto.uint64_field(21)
    # See :option:`--disable-hot-restart` for details.
    disable_hot_restart: bool = betterproto.bool_field(22)
    # See :option:`--enable-mutex-tracing` for details.
    enable_mutex_tracing: bool = betterproto.bool_field(23)
    # See :option:`--restart-epoch` for details.
    restart_epoch: int = betterproto.uint32_field(24)
    # See :option:`--cpuset-threads` for details.
    cpuset_threads: bool = betterproto.bool_field(25)
    # See :option:`--disable-extensions` for details.
    disabled_extensions: List[str] = betterproto.string_field(28)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.max_stats:
            warnings.warn(
                "CommandLineOptions.max_stats is deprecated", DeprecationWarning
            )
        if self.max_obj_name_len:
            warnings.warn(
                "CommandLineOptions.max_obj_name_len is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class TapRequest(betterproto.Message):
    """
    The /tap admin request body that is used to configure an active tap
    session.
    """

    # The opaque configuration ID used to match the configuration to a loaded
    # extension. A tap extension configures a similar opaque ID that is used to
    # match.
    config_id: str = betterproto.string_field(1)
    # The tap configuration to load.
    tap_config: "__service_tap_v2_alpha__.TapConfig" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Listeners(betterproto.Message):
    """
    Admin endpoint uses this wrapper for `/listeners` to display listener
    status information. See :ref:`/listeners
    <operations_admin_interface_listeners>` for more information.
    """

    # List of listener statuses.
    listener_statuses: List["ListenerStatus"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListenerStatus(betterproto.Message):
    """Details an individual listener's current status."""

    # Name of the listener
    name: str = betterproto.string_field(1)
    # The actual local address that the listener is listening on. If a listener
    # was configured to listen on port 0, then this address has the port that was
    # allocated by the OS.
    local_address: "__api_v2_core__.Address" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Certificates(betterproto.Message):
    """
    Proto representation of certificate details. Admin endpoint uses this
    wrapper for `/certs` to display certificate information. See :ref:`/certs
    <operations_admin_interface_certs>` for more information.
    """

    # List of certificates known to an Envoy.
    certificates: List["Certificate"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Certificate(betterproto.Message):
    # Details of CA certificate.
    ca_cert: List["CertificateDetails"] = betterproto.message_field(1)
    # Details of Certificate Chain
    cert_chain: List["CertificateDetails"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class CertificateDetails(betterproto.Message):
    """[#next-free-field: 7]"""

    # Path of the certificate.
    path: str = betterproto.string_field(1)
    # Certificate Serial Number.
    serial_number: str = betterproto.string_field(2)
    # List of Subject Alternate names.
    subject_alt_names: List["SubjectAlternateName"] = betterproto.message_field(3)
    # Minimum of days until expiration of certificate and it's chain.
    days_until_expiration: int = betterproto.uint64_field(4)
    # Indicates the time from which the certificate is valid.
    valid_from: datetime = betterproto.message_field(5)
    # Indicates the time at which the certificate expires.
    expiration_time: datetime = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class SubjectAlternateName(betterproto.Message):
    dns: str = betterproto.string_field(1, group="name")
    uri: str = betterproto.string_field(2, group="name")
    ip_address: str = betterproto.string_field(3, group="name")


from ... import type as __type__
from ...api.v2 import core as __api_v2_core__
from ...config.bootstrap import v2 as __config_bootstrap_v2__
from ...service.tap import v2alpha as __service_tap_v2_alpha__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
